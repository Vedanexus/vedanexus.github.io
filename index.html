<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Upside Realm</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #020204;
  touch-action: none;
  font-family: system-ui, sans-serif;
}
canvas { display: block; }
</style>
</head>

<body>
<canvas id="game"></canvas>

<!-- AUDIO (LOCAL STYLE, RELIABLE) -->
<audio id="ambient" preload="auto">
  <source src="https://assets.mixkit.co/music/preview/mixkit-dark-mystery-ambience-189.mp3">
</audio>
<audio id="hit" preload="auto">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-impact-soft-735.mp3">
</audio>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let W, H;
function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ===== SOUND CONTROL (GUARANTEED) ===== */
let soundStarted = false;
const ambient = document.getElementById("ambient");
const hitSound = document.getElementById("hit");

function startSound(){
  if(soundStarted) return;
  ambient.loop = true;
  ambient.volume = 0.4;
  ambient.play().catch(()=>{});
  soundStarted = true;
}

/* ===== BACKGROUND (UPSIDE WORLD EFFECT) ===== */
let bgOffset = 0;
function drawBackground(){
  bgOffset += 0.3;

  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0, "#120000");
  grad.addColorStop(1, "#000000");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);

  // drifting particles (fog)
  ctx.fillStyle = "rgba(255,0,0,0.05)";
  for(let i=0;i<40;i++){
    const x = (i*80 + bgOffset*2) % W;
    const y = (i*120 + bgOffset*3) % H;
    ctx.beginPath();
    ctx.arc(x,y,60,0,Math.PI*2);
    ctx.fill();
  }
}

/* ===== PLAYER (HUMAN CHARACTER) ===== */
const player = {
  x: W/2,
  y: H-100,
  vx: 0
};

function drawPlayer(){
  // aura
  ctx.beginPath();
  ctx.arc(player.x, player.y-20, 30, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,80,80,0.25)";
  ctx.fill();

  // head
  ctx.beginPath();
  ctx.arc(player.x, player.y-30, 10, 0, Math.PI*2);
  ctx.fillStyle = "#ffd6a5";
  ctx.fill();

  // body
  ctx.fillStyle = "#333";
  ctx.fillRect(player.x-6, player.y-20, 12, 24);

  // arms
  ctx.fillRect(player.x-16, player.y-18, 10, 4);
  ctx.fillRect(player.x+6, player.y-18, 10, 4);
}

/* ===== ENEMIES (SHADOW CREATURES) ===== */
let enemies = [];
let speed = 2.5;
let score = 0;
let gameOver = false;

function spawnEnemy(){
  enemies.push({
    x: Math.random()*W,
    y: -80,
    r: 28,
    wobble: Math.random()*Math.PI
  });
}

/* ===== INPUT ===== */
let dragging = false;

document.addEventListener("pointerdown", e => {
  startSound();

  if(gameOver){
    enemies = [];
    speed = 2.5;
    score = 0;
    gameOver = false;
    return;
  }
  dragging = true;
  player.x = e.clientX;
});

document.addEventListener("pointermove", e => {
  if(dragging) player.x = e.clientX;
});
document.addEventListener("pointerup", ()=> dragging=false);

/* ===== UPDATE ===== */
function update(){
  if(gameOver) return;

  if(Math.random()<0.025) spawnEnemy();

  enemies.forEach(en=>{
    en.y += speed;
    en.wobble += 0.05;
    en.x += Math.sin(en.wobble)*1.2;

    const d = Math.hypot(player.x-en.x, (player.y-20)-en.y);
    if(d < en.r+18){
      hitSound.play().catch(()=>{});
      gameOver = true;
    }
  });

  enemies = enemies.filter(e=>e.y<H+100);

  speed += 0.0015;
  score++;
}

/* ===== DRAW ===== */
function draw(){
  drawBackground();

  // enemies
  enemies.forEach(en=>{
    ctx.beginPath();
    ctx.arc(en.x,en.y,en.r,0,Math.PI*2);
    ctx.fillStyle="#2b0000";
    ctx.shadowBlur=30;
    ctx.shadowColor="#ff0000";
    ctx.fill();
  });

  drawPlayer();

  // UI
  ctx.shadowBlur=0;
  ctx.fillStyle="#fff";
  ctx.font="16px system-ui";
  ctx.fillText("Survival: "+score,10,22);

  if(gameOver){
    ctx.fillText("YOU WERE CONSUMED",W/2-90,H/2);
    ctx.fillText("TAP TO TRY AGAIN",W/2-85,H/2+24);
  }
}

/* ===== LOOP ===== */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
