<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VedaNexus Game</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;

  /* ðŸŽ¯ GAME BACKGROUND */
  background: 
    linear-gradient(
      rgba(0,0,0,0.35),
      rgba(0,0,0,0.35)
    ),
    url("bg.jpg") center center / cover no-repeat fixed;

  font-family: Arial, sans-serif;
}

canvas {
  display: block;
}
</style>
</head>

<body>
<canvas id="game"></canvas>

<script>
/* ===== CANVAS ===== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const heroImg = new Image();
heroImg.src = "hero.png";

const enemyImg = new Image();
enemyImg.src = "enemy_laptop.png";

let screenW = window.innerWidth;
let screenH = window.innerHeight;

function resize(){
  const dpr = window.devicePixelRatio || 1;
  screenW = window.innerWidth;
  screenH = window.innerHeight;

  canvas.width = screenW * dpr;
  canvas.height = screenH * dpr;
  canvas.style.width = screenW + "px";
  canvas.style.height = screenH + "px";

  ctx.setTransform(dpr,0,0,dpr,0,0);

  player.x = screenW/2 - player.w/2;
  player.y = screenH - 80;
}
window.addEventListener("resize", resize);

/* ===== PLAYER ===== */
const player = {
  x: screenW/2 - 24,
  y: screenH - 80,
  w: 48,
  h: 48,
  alive: true
};
resize();

/* ===== GAME STATE ===== */
let bullets = [];
let enemies = [];
let explosions = [];

let score = 0;
let WIN_SCORE = 300;
let bulletsLeft = 300;
let gameState = "PLAY";

let isFiring = false;
let fireCooldown = 0;
let hintTimer = 0;

/* ===== INPUT ===== */
window.addEventListener("pointerdown", e => {

  // ðŸ” restart if game ended
  if(gameState === "OVER" || gameState === "WIN"){
    restartGame();
    return;
  }

  // normal gameplay
  if(gameState !== "PLAY") return;

  isFiring = true;
  player.x = e.clientX - player.w / 2;
});

window.addEventListener("pointerup", ()=>{
  isFiring = false;
});

/* ===== ENEMY SPAWN ===== */
setInterval(()=>{
  if(gameState !== "PLAY") return;
  enemies.push({
    x: Math.random() * (screenW - 44),
    y: -44,
    w: 44,
    h: 44,
    speed: Math.min(2 + score * 0.05, 14)
  });
}, Math.max(300, 1000 - score * 2));


/* ===== HELPERS ===== */
function hit(a,b){
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

function createExplosion(x,y){
  for(let i=0;i<12;i++){
    explosions.push({
      x,y,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:20
    });
  }
}

/* ===== UPDATE ===== */
function update(){

  /* AUTO FIRE */
  if(isFiring && gameState==="PLAY" && bulletsLeft>0 && fireCooldown<=0){
    bulletsLeft--;
    bullets.push({
      x: player.x + player.w/2 - 3,
      y: player.y,
      w: 6,
      h: 12,
      speed: 8
    });
    fireCooldown = 10;
  }
  if(fireCooldown>0) fireCooldown--;

  if(gameState!=="PLAY" || !player.alive) return;

  bullets.forEach(b=>b.y -= b.speed);
  enemies.forEach(e=>e.y += e.speed);

  /* EXPLOSION UPDATE (ONLY HERE) */
  for(let k=explosions.length-1;k>=0;k--){
    const p = explosions[k];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    if(p.life<=0) explosions.splice(k,1);
  }

    /* BULLET vs ENEMY */
for(let i = bullets.length - 1; i >= 0; i--){
  for(let j = enemies.length - 1; j >= 0; j--){
    if(hit(bullets[i], enemies[j])){

      const ex = enemies[j].x + enemies[j].w / 2;
      const ey = enemies[j].y + enemies[j].h / 2;

      // remove bullet & enemy
      bullets.splice(i, 1);
      enemies.splice(j, 1);

      // explosion
      createExplosion(ex, ey);

      // score
      score++;

      // near-win hint
      if(score === 250){
        hintTimer = 120;
      }

      // WIN check (ONLY HERE)
      if(score >= WIN_SCORE){
        gameState = "WIN";
        player.alive = false;
      }

      // ammo recovery (NOT reset)
      if(Math.random() < 0.25){
        bulletsLeft = Math.min(bulletsLeft + 1, 300);
      }

      break;
    }
  }
}

  /* ENEMY vs PLAYER */
  for(let e of enemies){
    if(
  e.x < player.x + player.w - 6 &&
  e.x + e.w > player.x + 6 &&
  e.y < player.y + player.h - 6 &&
  e.y + e.h > player.y + 6
){

      player.alive = false;
      gameState = "OVER";
    }
  }

  bullets = bullets.filter(b=>b.y>-20);
  enemies = enemies.filter(e=>e.y<screenH+40);
}

function restartGame(){
  player.alive = true;

  bullets = [];
  enemies = [];
  explosions = [];

  score = 0;
  bulletsLeft = 300;

  hintTimer = 0;
  fireCooldown = 0;

  gameState = "PLAY";

  player.x = screenW / 2 - player.w / 2;
  player.y = screenH - 80;
}

/* ===== DRAW ===== */
function draw(){
  
  if(gameState==="WIN"){
    ctx.fillStyle="#fff";
    ctx.font="48px Arial";
    ctx.textAlign="center";
    ctx.fillText("IMPOSSIBLEâ€¦",screenW/2,screenH/2);
    return;
  }

  if(gameState === "OVER"){
  ctx.fillStyle="#fff";
  ctx.font="48px Arial";
  ctx.textAlign="center";
  ctx.fillText("GAME OVER", screenW/2, screenH/2);

  ctx.font="22px Arial";
  ctx.fillText("Tap to Play Again", screenW/2, screenH/2 + 50);
  return;
}


  ctx.fillStyle="#fff";
  ctx.font="20px Arial";
  ctx.textAlign="left";
  ctx.fillText(`Score: ${score}/${WIN_SCORE}`,20,60);
  ctx.fillText(`Ammo: ${bulletsLeft}`,20,90);

  if(hintTimer>0){
    ctx.textAlign="center";
    ctx.font="24px Arial";
    ctx.fillText("Almost thereâ€¦ stay sharp",screenW/2,120);
    hintTimer--;
  }

  ctx.drawImage(heroImg,player.x,player.y,player.w,player.h);

  ctx.fillStyle="yellow";
  bullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));

  explosions.forEach(p=>{
    ctx.fillStyle=`rgba(255,180,50,${p.life/20})`;
    ctx.beginPath();
    ctx.arc(p.x,p.y,4,0,Math.PI*2);
    ctx.fill();
  });

  enemies.forEach(e=>{
    ctx.drawImage(enemyImg,e.x,e.y,e.w,e.h);
  });
}

/* ===== LOOP ===== */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
